% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/EfficientProMisesSubj.R
\name{EfficientProMisesSubj}
\alias{EfficientProMisesSubj}
\title{Efficient ProMises model}
\usage{
EfficientProMisesSubj(
  data,
  maxIt = 10,
  t = 0.001,
  k = 0,
  Q = NULL,
  ref_ds = NULL,
  scaling = TRUE,
  reflection = TRUE,
  subj = TRUE,
  coord = NULL,
  l = NULL
)
}
\arguments{
\item{data}{data, i.e., list of matrices with dimension time points - voxels. Matrices can have different number of columns but must have the same numbers of rows.}

\item{maxIt}{maximum number of iteration}

\item{t}{the threshold value to be reached as the minimum relative reduction between the mean matrices}

\item{k}{value of the concentration parameter of the prior distribution}

\item{Q}{value of the location parameter of the prior distribution. It has dimension time-points x time-points, it could be not symmetric.}

\item{ref_ds}{starting matrix to align. If \code{NULL}, it is set to the element-wise arithmetic mean of the reduced matrices}

\item{scaling}{Flag to apply scaling transformation}

\item{reflection}{Flag to apply reflection transformation}

\item{subj}{Flag if each subject has his/her own set of voxel after voxel selection step. If \code{TRUE}, then \code{coord} has to be a list with each subjects' coordinates and the model will assume a different location parameter for the prior distribution of the rotation parameters.}

\item{coord}{list with 3-dim or 2-dim coordinates of the voxels of dimensions voxels x 2/3. Matrices can have different coordinates. If the location parameter \code{Q = NULL}, then \code{coord} is used to compute it (see Details)}

\item{l}{number of singular vectors required to obtained the reduced transformation of the matrices. If \code{NULL}, it is set equal to the number of rows.}
}
\value{
\code{EfficientProMisesSubj} returns a list with five components:
\item{\code{Xest}}{a list with the aligned matrices}
\item{\code{R}}{an array with the rotation matrices}
\item{\code{dist}}{a vector with length equal to the number of iterations that contains the distances between a reference matrix and the previous one}
\item{\code{count}}{the number of iterations done by the algorithm}
\item{\code{M}}{the element-wise mean matrix of the aligned matrices.}
}
\description{
Performs the functional alignment using the Efficient ProMises model allowing for different number of columns (voxel or pixel) between matrices.
}
\details{
\bold{Location parameter calculation:} 
If \code{Q=NULL} and \code{coord=NULL}, then \code{Q} is set to a matrix of zeros (i.e. no regularization, standard Generalized Procrustes Analysis).
If \code{Q=NULL} but \code{coord} is not null, then \code{Q} is calculated as follows:
\itemize{
\item For each input matrix \eqn{X_i \in \mathbb{R^{n\times m}}}, compute the thin-SVD \eqn{X_i=U_iD_iV_i^\top}, with \eqn{V_i\in \mathbb{R}^{m\times n}}
\item pre-multiply each coordinates matrix \eqn{C_i} (same for all the matrices if \code{subj=F}) by \eqn{V_i^\top}: \eqn{C_i^*=V_i^\top C_i}
\item compute the euclidean distance matrix \eqn{D} among points using the coordinates in \eqn{C_i^*}
\item set \eqn{Q=\exp\{-D\}}}
}
\examples{
{
## Create random list of matrices with different number of columns
X <- list(matrix(rnorm(100*4000), nrow=100),
          matrix(rnorm(100*3669), nrow=100),
          matrix(rnorm(100*3500), nrow=100))
## Align the matrices with the Efficient ProMises model. 
## Since subj = F and Q is a single matrix, all the rotation parameters 
## will have the same location parameter
out <- EfficientProMisesSubj(data = X, maxIt = 10, t = 1, k = 1,
                             Q = diag(1,100), subj = FALSE, scaling = FALSE,
                             reflection = FALSE, ref_ds = NULL, coord = NULL, 
                             l = NULL)
                             
## create random coordinates
C <- list(cbind(sample(1:4000), sample(1:4000)),
          cbind(sample(1:3669), sample(1:3669)),
          cbind(sample(1:3500), sample(1:3500)))

## Align matrices considering a different location parameter for every 
## matrix, calculated as specified in details
out1 <- EfficientProMisesSubj(data = X, maxIt = 10, t = 1, k = 1,
                              Q = NULL, subj = TRUE, scaling = FALSE,
                              reflection = FALSE, ref_ds = NULL, coord = C, 
                              l = NULL)   
                              
## Extract only the first 15 singular vectors to compute the low-dimensional
## representation of the matrices
out2 <- EfficientProMisesSubj(data = X, maxIt = 10, t = 1, k = 1,
                              Q = NULL, subj = TRUE, scaling = FALSE,
                              reflection = FALSE, ref_ds = NULL, coord = C, 
                              l = 15)                         
}
}
\references{
For the theory on the Efficient ProMises model see: A. Andreella 
and L. Finos (2022), Procrustes analysis for high-dimensional data, 
Psychometrika 87, 1422-1438
}
\author{
Angela Andreella and Daniela Corbetta
}
